{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/* eslint-disable react/no-find-dom-node */\n\n\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // the last page we have items for\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect(); // Need to adjust for cases such as show where first and last page item\n      // refs can be much larger than the step.\n\n      var initialPage = show ? Math.floor(show / step) : 0;\n      var nextPageHeight = (endRect.top + endRect.height - beginRect.top) / (initialPage + 1); // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step, show]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4; // nextBeginPage will increment/decrement when using replace, otherwise\n      // the beginPage will be at 0.\n\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0; // Increment nextEndPage when nearing end of current page\n\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var ref;\n    var child = children(item, itemsIndex, ref); // Set firstPageItemRef & lastPageItemRef if we don't know the pageHeight.\n\n    if (!pageHeight && itemsIndex === 0) {\n      // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n      child = children(item, itemsIndex, firstPageItemRef);\n\n      if (child.ref !== firstPageItemRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"first\",\n          ref: firstPageItemRef\n        }, child);\n      }\n    }\n\n    if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      // If show && show > step, we only want a single lastPageItemRef and it\n      // should be set at lastIndex. Ignore step - 1 scenario, otherwise will\n      // create duplicates.\n      child = show && show > step && itemsIndex === step - 1 ? child : children(item, itemsIndex, lastPageItemRef); // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n\n      if (child.ref !== lastPageItemRef && !(show && show > step && itemsIndex === step - 1)) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"last\",\n          ref: lastPageItemRef\n        }, child);\n      }\n    } // Set showRef\n\n\n    if (show && show === itemsIndex) {\n      child = children(item, itemsIndex, showRef);\n\n      if (child.ref !== showRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"show\",\n          ref: showRef\n        }, child);\n      }\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };","map":{"version":3,"sources":["/Users/erwanbeguin/Documents/Developper/ynov/dataviz/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","React","Component","useEffect","useMemo","useRef","useState","findDOMNode","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","Ref","_Component","apply","arguments","_proto","render","children","props","InfiniteScroll","_ref","_ref$items","items","onMore","renderMarker","replace","show","_ref$step","step","lastPage","Math","floor","length","_useState","beginPage","setBeginPage","_useState2","endPage","setEndPage","_useState3","pageHeight","setPageHeight","_useState4","pageArea","setPageArea","_useState5","multiColumn","setMultiColumn","_useState6","pendingLength","setPendingLength","belowMarkerRef","firstPageItemRef","lastPageItemRef","showRef","current","beginRect","getBoundingClientRect","endRect","initialPage","nextPageHeight","top","height","nextMultiColumn","nextPageArea","width","scrollParents","onScroll","scrollParent","document","documentElement","scrollTop","body","window","innerHeight","innerWidth","rect","offset","nextBeginPage","min","max","nextEndPage","ceil","forEach","addEventListener","removeEventListener","timer","setTimeout","showNode","scrollIntoView","clearTimeout","firstIndex","lastIndex","result","marker","createElement","key","flex","cloneElement","push","slice","item","index","itemsIndex","ref","child","_marker","InfiniteScrollDoc","process","env","NODE_ENV","require","doc","InfiniteScrollWrapper"],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint-disable react/no-find-dom-node */\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n  // the last page we have items for\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect(); // Need to adjust for cases such as show where first and last page item\n      // refs can be much larger than the step.\n\n      var initialPage = show ? Math.floor(show / step) : 0;\n      var nextPageHeight = (endRect.top + endRect.height - beginRect.top) / (initialPage + 1); // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step, show]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4; // nextBeginPage will increment/decrement when using replace, otherwise\n      // the beginPage will be at 0.\n\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0; // Increment nextEndPage when nearing end of current page\n\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var ref;\n    var child = children(item, itemsIndex, ref); // Set firstPageItemRef & lastPageItemRef if we don't know the pageHeight.\n\n    if (!pageHeight && itemsIndex === 0) {\n      // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n      child = children(item, itemsIndex, firstPageItemRef);\n\n      if (child.ref !== firstPageItemRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"first\",\n          ref: firstPageItemRef\n        }, child);\n      }\n    }\n\n    if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      // If show && show > step, we only want a single lastPageItemRef and it\n      // should be set at lastIndex. Ignore step - 1 scenario, otherwise will\n      // create duplicates.\n      child = show && show > step && itemsIndex === step - 1 ? child : children(item, itemsIndex, lastPageItemRef); // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n\n      if (child.ref !== lastPageItemRef && !(show && show > step && itemsIndex === step - 1)) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"last\",\n          ref: lastPageItemRef\n        }, child);\n      }\n    } // Set showRef\n\n\n    if (show && show === itemsIndex) {\n      child = children(item, itemsIndex, showRef);\n\n      if (child.ref !== showRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"show\",\n          ref: showRef\n        }, child);\n      }\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };"]},"metadata":{},"sourceType":"module"}