{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nclass OpenStreetMap {\n  constructor(options) {\n    //Bounds are expected to be a nested array of [[sw_lat, sw_lng],[ne_lat, ne_lng]].\n    // We convert them into a string of 'x1,y1,x2,y2' which is the opposite way around from lat/lng - it's lng/lat\n    let boundsUrlComponent = \"\";\n    let regionUrlComponent = \"\";\n\n    if (options && options.searchBounds && options.searchBounds.length) {\n      const reversedBounds = options.searchBounds.reduce((acc, b) => [...acc, b.lng, b.lat], []);\n      boundsUrlComponent = `&bounded=1&viewbox=${reversedBounds.join(\",\")}`;\n    }\n\n    if (options && \"region\" in options) {\n      regionUrlComponent = `&countrycodes=${options.region}`;\n    }\n\n    this.url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&polygon_svg=1&namedetails=1${boundsUrlComponent}${regionUrlComponent}&q=`;\n  }\n\n  search(query) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const rawResponse = yield fetch(this.url + query);\n      const response = yield rawResponse.json();\n      return this.formatResponse(response);\n    });\n  }\n\n  formatResponse(response) {\n    const resources = response;\n    const count = response.length;\n    const info = count > 0 ? resources.map(e => ({\n      bounds: e.boundingbox.map(bound => Number(bound)),\n      latitude: Number(e.lat),\n      longitude: Number(e.lon),\n      name: e.display_name\n    })) : \"Not Found\";\n    return {\n      info: info,\n      raw: response\n    };\n  }\n\n}\n\nexport { OpenStreetMap };","map":{"version":3,"sources":["/Users/erwanbeguin/Documents/Developper/ynov/dataviz/node_modules/react-leaflet-search/lib/Providers/OpenStreetMap.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","OpenStreetMap","constructor","options","boundsUrlComponent","regionUrlComponent","searchBounds","length","reversedBounds","reduce","acc","b","lng","lat","join","region","url","search","query","rawResponse","fetch","response","json","formatResponse","resources","count","info","map","bounds","boundingbox","bound","Number","latitude","longitude","lon","name","display_name","raw"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass OpenStreetMap {\n    constructor(options) {\n        //Bounds are expected to be a nested array of [[sw_lat, sw_lng],[ne_lat, ne_lng]].\n        // We convert them into a string of 'x1,y1,x2,y2' which is the opposite way around from lat/lng - it's lng/lat\n        let boundsUrlComponent = \"\";\n        let regionUrlComponent = \"\";\n        if (options && options.searchBounds && options.searchBounds.length) {\n            const reversedBounds = options.searchBounds.reduce((acc, b) => [...acc, b.lng, b.lat], []);\n            boundsUrlComponent = `&bounded=1&viewbox=${reversedBounds.join(\",\")}`;\n        }\n        if (options && \"region\" in options) {\n            regionUrlComponent = `&countrycodes=${options.region}`;\n        }\n        this.url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&polygon_svg=1&namedetails=1${boundsUrlComponent}${regionUrlComponent}&q=`;\n    }\n    search(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rawResponse = yield fetch(this.url + query);\n            const response = yield rawResponse.json();\n            return this.formatResponse(response);\n        });\n    }\n    formatResponse(response) {\n        const resources = response;\n        const count = response.length;\n        const info = count > 0\n            ? resources.map((e) => ({\n                bounds: e.boundingbox.map((bound) => Number(bound)),\n                latitude: Number(e.lat),\n                longitude: Number(e.lon),\n                name: e.display_name,\n            }))\n            : \"Not Found\";\n        return {\n            info: info,\n            raw: response,\n        };\n    }\n}\nexport { OpenStreetMap };\n"]},"metadata":{},"sourceType":"module"}